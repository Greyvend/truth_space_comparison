\documentclass{cmi}

\usepackage{upgreek}
\usepackage{amssymb,amsmath}
\usepackage[utf8]{inputenc}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{xcolor}
\usepackage{mdwlist}
\usepackage{enumitem}
\usepackage{pgfplots}

\pgfplotsset{compat=1.3}

\floatname{algorithm}{Алгоритм}

\newtheorem{mydef}{Определение}
\newtheorem{statement}{Утверждение}
\newtheorem*{consequence}{Следствие}

\def \eval #1#2{\left.#1\right\vert_{#2}}
\def \<#1> {\langle #1 \rangle}
\def \n #1{\mathit{#1}}
\def \bigcupn {\bigcup\limits_{v=1}^{n}}


\begin{document}

\classify{УДК 004.652}
\author{С.В.~Мосин}
\title{Сравнение областей истинности запросов к реляционной базе данных}


\maketitle{}

% оформление аннотации
\begin{abstract}%
В данной статье предлагается описание подходов и алгоритмов аналитического сравнения пользовательских
запросов к реляционной базе данных. Такое сравнение имеет целью установление возможности частичного или
полного использования закэшированных на компьютере пользователя запросов к СУБД. В случае, если результат
выполнения пользовательского запроса полностью содержится в кэше, то данные можно взять оттуда, минуя
запрос к удаленному серверу. Предложенный метод также может быть использован для определения недостающих в
кэше данных и последующего запроса только на эти данные. Для этого также используются аналитические
вычисления, что экономит сетевой трафик и время на выполнение запросов и является принципиальным отличием
данной технологии от существующих аналогов. Алгоритмы сравнения запросов основаны на применении аппарата
логики предикатов, где в качестве формул выступают логические ограничения SQL, а предикатами служат операции
SQL.

\keywords{реляционная база данных, кэш, область истинности.}
\end{abstract}

%Верхние колонтитулы
\markboth{С.В.~Мосин}{Сравнение областей истинности запросов к реляционной базе данных}

% Заголовки разделов формируются при помощи команд  \section{}, \subsection{}, \subsubsection{}

\section*{Введение}
\label{sec-intro}
Данная работа развивает и объясняет идеи, описанные в статье \cite{mosin_zykin}, представляя подходы к аналитическому сравнению логических формул, используемых в универсальных реляционных запросах (см. определение далее).

Основным инструментом работы с логическими формулами является аппарат математической логики, конкретно,
логики первого порядка, или логики предикатов \cite{hilbert, mendelson, church}. Данная работа не ставит
целью получение новых результатов в области математической логики, а лишь использует имеющуюся теорию в
применении к логическим ограничениям языка SQL, расширяя таким образом возможности анализа пользовательских
запросов по сравнению с классическими подходами СУБД, где нет возможности частичного или комбинированного
использования закэшированных запросов.

В книге \cite{date} подробно описано то, как логика предикатов используется в языке SQL в виде реляционного исчисления (relational calculus), а также приведены основные эквивалентности логических предикатов, используемые в данной статье.


В разделе~\ref{sec-problem} описывается формализованная постановка задачи. Секция~\ref{sec-logicak_operations} является основной, так как представляет подходы к аналитическому сравнению простейших операций языка SQL, из которых строятся все логические формулы. В следующем разделе,~\ref{sec-comparison}, выводятся основные эквивалентности, используемые при определении возможности использования кэша. Заключительный раздел~\ref{sec-algorithm} объединяет полученные результаты в виде схемы алгоритма использования кэша в ходе исполнения запросов к реляционной базе данных. В разделе~\nameref{sec-conclusion} сделано обобщение полученных результатов и приведены дальнейшие направления исследований.


\section{Постановка задачи}
\label{sec-problem}
Будем рассматривать реляционную базу данных со схемой $R = \{R_1, R_2, \dots, R_n\}$.

\begin{mydef}
	Универсальным реляционным запросом называется запрос следующего вида:
	$$P = \pi_X(\sigma_{F} (R_1 \Join \dots \Join R_m )), m \in [1, \dots, n]$$
\end{mydef}

Логические формулы, по которым проводится селекция, будем рассматривать в дизъюнктивной нормальной форме. В общем случае формула $F$ имеет вид

\begin{equation}
F = K_1 \vee K_2 \vee \dots \vee K_m ,
\label{def_F_1}
\end{equation}
\begin{equation}
K_i = T_1\ \&\ T_2 \dots \&\ T_n, i = 1, \dots, m ,
\label{def_F_2}
\end{equation}
где $T_j, j = 1, \dots, n$ - предикаты, в которых явным образом
специфицированы расширенные имена атрибутов $R_i.A_j$ (атрибут $A_j$ в отношении
$R_i$):

Возможные значения  $T_j$:
\begin{itemize}
	\item операция сравнения $ \n{Expr}_1\ \theta\ \n{Expr}_2\ $, $\theta$ – операция
	сравнения $(\theta \in \{=, \neq, >, <, \leq, \geq\})$, $\n{Expr}_i$ –
	согласованные по типам допустимые выражения, определенные на множестве
	расширенных имен атрибутов и констант;
	\item операция $\n{Expr}_1\ \n{[NOT]}\ \n{BETWEEN}\ \n{Expr}_2\ \n{AND}\
	\n{Expr}_3$ (содержимое в прямоугольных скобках $[*]$ для предиката не
	является обязательным при написании);
	\item операция $\n{Expr}\ \n{[NOT]}\ \n{IN}\ S$, где $S$ – список значений либо
	подзапрос, результатом которого является столбец атрибута $A_j$ в отношении
	$R_i$;
	\item операция $\n{Str}_1\ \n{[NOT]}\ \n{LIKE}\ \n{Str}_2$, где $\n{Str}_i$ –
	строки;
	\item операция $\n{Expr}\ \theta\ \n{ALL/ANY}\ S$.
\end{itemize}

\begin{mydef}
	Множество атрибутов, входящих в формулу, выражает размерность формулы и
	обозначается $\<F> $.
	
	\begin{equation}
	\<F> = \{R_1^F.A_1^F, \dots, R_k^F.A_k^F\}
	\label{def_F_3}
	\end{equation}
\end{mydef}

Перечисленные варианты операций используют не все возможности языка SQL.
Например, предикат $\n{EXISTS}$ не используется, поскольку в нем явно не
специфицированы расширенные имена атрибутов, предикат $\n{NULL}$ используется
в данной работе для другой цели.

В статье \cite{mosin_zykin} приведен алгоритм преобразования логических формул, которое позволяет избежать получения значения $\n{UNKNOWN}$ в результате вычисления значений формул. Далее будем предполагать, что все формулы $F$ являются преобразованными.

Введем в рассмотрение множество $\mathcal{A} =$ $\{(a_1, \dots, a_n)
\mid a_i \in Dom(A_i), i=1,\dots,n\}$, где $Dom(A_i)$ - множество всех допустимых значений атрибута $A_i$.
Декартово произведение $Dom(A_1)\times Dom(A_2)\times \dots \times Dom(A_n)$ - $n$-мерное пространство
значений всех атрибутов базы данных.

\begin{mydef}
	Областью истинности логической формулы $F$, заданной (\ref{def_F_1}),
	(\ref{def_F_2}), (\ref{def_F_3}), является множество, определяемое по следующему
	правилу: $M (F) = \{a \in \mathcal{A} \mid F(a) = \n {TRUE}\}$.
\end{mydef}

В соответствии с данными определениями легко понять, как будут устроены операции
над областями истинности, соответствующими формулам. $M (F)$ для некоторой формулы
$F$, заданной своей ДНФ, является объединением областей истинности, представленных
отдельными конъюнктами формулы. Область истинности каждого конъюнкта определяется
определяется как пересечение областей истинности предикатов, входящих в него.

Далее введем определения, касающиеся модификации вхождения атрибутов в
логические формулы.

\begin{mydef}
	Проекцией логической формулы $F$, заданной (\ref{def_F_1}), (\ref{def_F_2}),
	(\ref{def_F_3}), на множество атрибутов $X$ называется логическая
	формула $F[X], \<F[X]> $
	$= X$, в которой все термы, содержащие
	атрибуты $R_i^F.A_i^F \notin X$, заменены на тривиальный терм $\n{TRUE}$.
	\label{projection}
\end{mydef}

Основные теоретические результаты, позволяющие судить о возможности использования кэша при выполнении запросов:
\begin{theorem}
	$P^{\ast} \subseteq \pi_{X^{\ast}} ( \sigma_{F^{\ast}[X]} (P_1 \Join \dots \Join
	P_n))$, где $X = \bigcupn X_{v}$ если:
	\\а) $X^{\ast} \subseteq X$
	\\б)
	$ \bigcupn \{R^{v}_{1}, \ldots, R^{v}_{s(v)}\} = \{R'_{1}, \ldots, R'_{s'}\}
	\subseteq
	\{R^{\ast}_{1}, \ldots, R^{\ast}_{l}\} $
	\\в) $M(F^{\ast}) \subseteq M(F_{v}), v = 1,\dots,n $.
	\label{th_mult}
\end{theorem}

\begin{theorem}
	$P^{\ast} =  \pi_{X^{\ast}} ( \sigma_{F^{\ast}} (P_1 \Join \dots \Join
	P_n))$, где $X = \bigcupn X_{v}$ если:
	\\а) $X^{\ast} \subseteq X$, $X_v \supseteq \<\Join_{i=1}^{s(v)} R^v_i> \cap (\bigcup\limits_{\substack{w=1\\ w \neq v}}^{n} \<\Join_{i=1}^{s(w)} R^w_i> ), v = 1,\dots,n$
	\\б)
	$ \bigcupn \{R^{v}_{1}, \ldots, R^{v}_{s(v)}\} = \{R'_{1}, \ldots, R'_{s'}\}
	= \{R^{\ast}_{1}, \ldots, R^{\ast}_{l}\} $
	\\в) $M(F^{\ast}) \subseteq M(F_{v}), v = 1,\dots,n $
	\\г) $ \<F^{\ast}> \subseteq X $.
	\label{th_mult_eq}
\end{theorem}

Доказательства теорем приведены в статье \cite{mosin_zykin}.

\section{Логические операции над предикатами}
\label{sec-logicak_operations}
Для проверки условий теорем необходимо уметь сравнивать логические формулы, не прибегая к запросам
на сервер. Для этого, в свою очередь, нам понадобится вычислять значение логических операций $\vee,
\&, \neg$ над предикатами $T_j, j=1, \dots, n$, из которых состоят логические формулы. Определение значения логической формулы аналитически возможно в случае, если формула не зависит от значений атрибутов БД. Приведение к такому виду возможно в ряде изложенных далее случаев.

\subsection{Упрощение конъюнкции и дизъюнкции простых предикатов}
\begin{enumerate}
	\item $ \n{Expr}_1\ \theta\ \n{Expr}_2\ $, $(\theta \in \{=, \neq, >, <, \leq, \geq\})$\\
	Данный тип операций определяет простейшие арифметические операции равенства и неравенства. Сравнение
	таких предикатов сводится к применению элементарных правил решения неравенств.
	
	Пусть даны следующие предикаты:
	\begin{itemize}
		\item $T_1 = (R_i.A_j\ \theta_1\ a),\ a \in Dom(R_i.A_j)$
		\item $T_2 = (R_i.A_j\ \theta_2\ b),\ b \in Dom(R_i.A_j)$
	\end{itemize}
	
	Рассмотрим всевозможные комбинации конъюнкции и дизъюнкции данных типов предикатов, при которых в
	результате получается тривиальное значение $\n{TRUE}$ либо $\n{FALSE}$.
	
	Заметим, что операции $\leq,
	\geq$ сводятся к операциям $<, >, =, \neq$: $x_1 \leq x_2 \sim x_1 < x_2 \vee x_1 = x_2$, поэтому мы исключаем их из дальнейшего рассмотрения.
	
	Также обратим внимание, что если $\theta_1 = \theta_2$, то $T_1\ \&\ T_2 \equiv \n{TRUE} \iff a = b$.
	Далее рассматриваем только различные операции $\theta_1$ и $\theta_2$.
	
	\begin{enumerate}
		\item $\theta_1 = $ ``$=$''
		\begin{enumerate}
			\item $\theta_2 = $ ``$\neq$''  	
			$$T_1\ \&\ T_2 \equiv \n{TRUE} \iff a = b$$
			$$T_1\ \&\ T_2 \equiv \n{FALSE} \iff a \neq b$$
			
			\item $\theta_2 = $ ``$<$''
			$$T_1\ \&\ T_2 \equiv \n{FALSE} \iff a > b$$
			
			\item $\theta_2 = $ ``$>$''
			$$T_1\ \&\ T_2 \equiv \n{FALSE} \iff a < b$$
		\end{enumerate}
		
		\item $\theta_1 = $ ``$\neq$''
		
		Никакие прочие операции не дают в результате тождественной истины или лжи при проведении конъюнкции или дизъюнкции с $T_1$ в данном случае.
		
		\item $\theta_1 = $ ``$<$''
		\begin{enumerate}
			\item $\theta_2 = $ ``$>$''
			
			$$T_1\ \&\ T_2 \equiv \n{FALSE} \iff a < b$$
			$$T_1 \vee T_2 \equiv \n{TRUE} \iff a \geq b$$
		\end{enumerate}
	\end{enumerate}
	
	
	\item $\n{Expr}_1\ \n{[NOT]}\ \n{BETWEEN}\ \n{Expr}_2\ \n{AND}\ \n{Expr}_3$\\
	Эта и дальнейшие операции (кроме $\n{LIKE}$) сводятся к операциям первого типа:
	\begin{enumerate}
		\item $\n{Expr}_1\ \n{BETWEEN}\ \n{Expr}_2\ \n{AND}\ \n{Expr}_3$\\
		$T = (\n{R_i.A_j}\ \n{BETWEEN}\ a\ \n{AND}\ b),\ a, b \in Dom(R_i.A_j)$
		Эквивалентное представление данной операции: $T = (a \leq \n{R_i.A_j} \leq b)$
		\item $\n{Expr}_1\ \n{NOT}\ \n{BETWEEN}\ \n{Expr}_2\ \n{AND}\ \n{Expr}_3$\\
		$T = (\n{R_i.A_j}\ \n{NOT}\ \n{BETWEEN}\ a\ \n{AND}\ b),\ a, b \in Dom(R_i.A_j)$
		Эквивалентное представление данной операции: $T = (\n{R_i.A_j} \leq a \vee \n{R_i.A_j} \geq b)$
	\end{enumerate}
	
	
	\item $\n{Expr}\ \n{[NOT]}\ \n{LIKE}\ \n{Str}$,\\ $\n{Expr}$ -- атрибут строкового типа данных,
	$\n{Str}$ -- строка особого типа, содержащая управляющие символы языка SQL. К ним относятся:
	\begin{itemize}
		\item '\%' Данный символ совпадает при сравнении с любым количеством любых символов строки
		\item '\_' Данный символ совпадает при сравнении с одним любым символом строки
	\end{itemize}
	
	Различные диалекты языка SQL от разных производителей СУБД дополняют этот список другими
	управляющими конструкциями, так что он может отличаться в зависимости от реализации. Но так или
	иначе сравнение предикатов такого вида имеет схожую схему. По сути данная операция представляет из
	себя упрощенное регулярное выражение. Проведение таких операций, как дизъюнкция, конъюнкция и
	отрицание, осуществляется точно также как для регулярных выражений.
	
	
	\item \label{itm:IN_S} $\n{Expr}\ \n{[NOT]}\ \n{IN}\ S$, где $S$ - список значений или подзапрос,
	результат которого - это множество значений атрибута $R_i.A_j$.
	\begin{enumerate}
		\item $\n{Expr}\ \n{IN}\ S$\\
		Если $S$ - это список заранее заданных значений:\\
		$T = (\n{R_i.A_j}\ \n{IN}\ \{s_1, s_2, \dots, s_l \}),\ s_k \in Dom(R_i.A_j), k = 1, \dots, l$\\
		Эквивалентное представление: $T = (\bigvee\limits_{k=1}^{l} \n{R_i.A_j} = s_k)$\\
		Если $S$ - это подзапрос:\\
		$T = (\n{R_i.A_j}\ \n{IN}\ \pi_{R_i.A_j} (\sigma_F (R_1 \Join \dots \Join R_n)))$\\
		\item $\n{Expr}\ \n{NOT}\ \n{IN}\ S$\\
		Если $S$ - это список заранее заданных значений:\\
		$T = (\n{R_i.A_j}\ \n{NOT}\ \n{IN}\ \{s_1, s_2, \dots, s_l \}),\ s_k \in Dom(R_i.A_j), k = 1,
		\dots, l$\\
		Эквивалентное представление: $T = (\bigwedge\limits_{k=1}^{l} \n{R_i.A_j} \ne s_k)$\\
		Если $S$ - это подзапрос:\\
		$T = (\n{R_i.A_j}\ \n{IN}\ \pi_{R_i.A_j} (\sigma_F (R_1 \Join \dots \Join R_n)))$\\
	\end{enumerate}
	
	
	\item \label{itm:ALL/ANY_S} $\n{Expr}\ \theta\ \n{ALL/ANY}\ S$.\\
	Данная операция является обобщением операций первого типа и сводится к нему в случае простого списка
	значений.
	\begin{enumerate}
		\item $\n{Expr}\ \theta\ \n{ALL}\ S$\\ Если $S$ - это список заранее заданных значений:\\
		$T = (\n{R_i.A_j}\ \theta\ \n{ALL}\ \{s_1, s_2, \dots, s_l \}),\ s_k \in Dom(R_i.A_j), k = 1,
		\dots, l$\\  
		Эквивалентное представление:\\
		$T = (\n{R_i.A_j}\ \theta\ s_1\ \&\ \n{R_i.A_j}\ \theta\ s_2\ \&\ \dots \&\ \n{R_i.A_j}\ \theta\
		s_k)$\\
		Если $S$ - это подзапрос:\\
		$T = (\n{R_i.A_j}\ \theta\ \n{ALL}\ \pi_{R_i.A_j} (\sigma_F (R_1 \Join \dots \Join R_n)))$\\
		\item $\n{Expr}\ \theta\ \n{ANY}\ S$\\
		$T = (\n{R_i.A_j}\ \theta\ \n{ANY}\ \{s_1, s_2, \dots, s_l \}),\ s_k \in Dom(R_i.A_j), k = 1,
		\dots, l$\\  
		Эквивалентное представление:\\
		$T = (\n{R_i.A_j}\ \theta\ s_1\ \vee\ \n{R_i.A_j}\ \theta\ s_2\ \vee\ \dots \vee\ \n{R_i.A_j}\
		\theta\ s_k)$\\
		Если $S$ - это подзапрос:\\
		$T = (\n{R_i.A_j}\ \theta\ \n{ANY}\ \pi_{R_i.A_j} (\sigma_F (R_1 \Join \dots \Join R_n)))$\\
	\end{enumerate}
\end{enumerate}

\subsection{Упрощение конъюнкции и дизъюнкции предикатов, содержащих подзапросы}
Если в операциях \ref{itm:IN_S} и \ref{itm:ALL/ANY_S} типа встречается подзапрос,
аналитическое сравнение таких предикатов возможно только в некоторых частных случаях. Дело в том,
что нельзя заранее определить область истинности таких предикатов, так как она зависит от реализации
базы данных. Использование же информации о БД противоречит аналитическому подходу. Рассмотрим
условия, при которых все-таки возможно их сравнивать аналитически.

Пусть подзапросы имеют следующий вид:
$$S_1 = \pi_{R_i.A_j} (\sigma_{F_1} (R_1^1 \Join \dots \Join R_l^1))$$
$$S_2 = \pi_{R_i.A_j} (\sigma_{F_2} (R_1^2 \Join \dots \Join R_k^2))$$

$S_1$ и $S_2$ являются множествами и, следовательно, могут быть следующие ситуации:
\begin{enumerate}
	\item $S_1 \cap S_2 = \emptyset $\\
	Определить, что подзапросы точно не пересекаются, аналитически можно, если $M(F_1) \cap M(F_2) =
	\emptyset$. В данном случае наблюдаются следующие эквивалентности:
	\begin{enumerate}
		\item $(\n{R_i.A_j}\ \n{IN}\ S_1)\ \&\ (\n{R_i.A_j}\ \n{IN}\ S_2) \equiv \n{FALSE}$
		\item $(\n{R_i.A_j}\ = \n{ALL}\ S_1)\ \&\ (\n{R_i.A_j}\ = \n{ALL}\ S_2) \equiv \n{FALSE}$
	\end{enumerate}
	\item $S_1 \cap S_2 \neq \emptyset $\\
	В общем случае нет возможности установить упрощения к виду тождественной истины/лжи.
\end{enumerate}

\subsection{Операция отрицания для всех типов предикатов}
Логическое отрицание ставит в соответствие противоположный предикат в каждом из случаев.
\begin{enumerate}
	\item $ \n{Expr}_1\ \theta\ \n{Expr}_2\ $, $(\theta \in \{=, \neq, >, <, \leq, \geq\})$\\
	$T = (\n{R_i.A_j}\ \theta\ a)\ \rightarrow \neg T = (\n{R_i.A_j}\ \neg \theta\ a),
	a \in Dom(R_i.A_j)$
	\begin{itemize}
		\item $T = (\n{R_i.A_j} = a) \rightarrow \neg T =  (\n{R_i.A_j}\ \neq a)$
		\item $T = (\n{R_i.A_j} > a) \rightarrow \neg T =  (\n{R_i.A_j}\ < a)$
		\item $T = (\n{R_i.A_j} \geq a) \rightarrow \neg T = (\n{R_i.A_j}\ \leq
		a)$
	\end{itemize}
	\item $\n{Expr}_1\ \n{[NOT]}\ \n{BETWEEN}\ \n{Expr}_2\ \n{AND}\ \n{Expr}_3$\\
	$T = (\n{R_i.A_j}\ \n{BETWEEN}\ a\ \n{AND}\ b),\ a, b \in Dom(R_i.A_j) \rightarrow$\\
	$\rightarrow \neg T = (\n{R_i.A_j}\ \n{NOT}\ \n{BETWEEN}\ a\ \n{AND}\ b)$
	\item $\n{Expr}\ \n{[NOT]}\ \n{LIKE}\ \n{Str}$\\
	$T = (\n{R_i.A_j}\ \n{LIKE}\ \n{Str}) \rightarrow \neg T = (\n{R_i.A_j}\ \n{NOT}\ \n{LIKE}\
	\n{Str})$
	\item $\n{Expr}\ \n{[NOT]}\ \n{IN}\ S$\\
	$T = (\n{R_i.A_j}\ \n{IN}\ S)\ \rightarrow \neg T = (\n{R_i.A_j}\ \n{NOT}\ \n{IN}\ S)$
	\item $\n{Expr}\ \theta\ \n{ALL/ANY}\ S$\\
	$T = (\n{R_i.A_j}\ \theta\ \n{ALL}\ S)\ \rightarrow \neg T = (\n{R_i.A_j}\ \neg \theta\ \n{ANY}\ S
	)$
\end{enumerate}


\section{Операции над областями истинности логических формул}
\label{sec-comparison}
Здесь и далее будем рассматривать только случай нескольких промежуточных
представлений как более общий.

Проверка на пустоту пересечения областей истинности логических формул осуществляется следующим образом: $M(F^{\ast}) \cap (M(F_1) \cup M(F_2) \cup \dots \cup M(F_n)) = \emptyset \iff M(F^{\ast}\ \&\ (F_1 \vee F_2 \vee \dots \vee F_n)) = \emptyset \iff
F^{\ast}\ \&\ (F_1 \vee F_2 \vee \dots \vee F_n) \equiv \n{FALSE}$.

Для выполнения условий теорем \ref{th_mult}, \ref{th_mult_eq} требуется установить включение области
истинности формулы пользовательского запроса $M(F^{\ast})$ в область истинности формул промежуточных представлений $M(F_1), M(F_2), \dots, M(F_n)$, или $M(F^{\ast}) \subseteq M(F_{v}),
v = 1,\dots, n$, то есть должно быть выполнено $M(F^{\ast}) \subseteq M(F_1)\ \&\ M(F^{\ast}) \subseteq M(F_2)\ \&\ \dots\ \&\ M(F^{\ast}) \subseteq M(F_n) \equiv \n{TRUE} \iff M(F^{\ast}) \subseteq M(F_1\ \&\ F_2\ \&\ \dots\ \&\ F_n) \equiv \n{TRUE} \iff F^{\ast} \rightarrow F_1\ \&\ F_2\ \&\ \dots\ \&\ F_n \equiv \n{TRUE} \iff F_1\ \&\ F_2\ \&\ \dots \&\ F_n \vee \neg F^{\ast} \equiv \n{TRUE} $.

Практическая проверка данных условий аналитическим способом возможна путем упрощения формул при
помощи правил, изложенных в предыдущем пункте.

Для получения недостающих в кэше данных необходимо уметь строить формулу, область истинности которой
равна разности областей истинности исходных формул:
$M(F^{\ast}) \setminus M(F_1\ \&\ F_2\ \&\ \dots\ \&\ F_n) = M(F_{n + 1})$.
Такая формула $F_{n + 1}$, очевидно, выражается следующим образом: $F_{n + 1} = F^{\ast}\ \&\ \neg(F_1\ \&\ F_2\ \&\ \dots\ \&\ F_n)$.


\section{Алгоритм использования кэшированных данных}
\label{sec-algorithm}
Далее приводится схема алгоритма аналитической проверки логических ограничений и определения
недостающих в кэше данных. Затем рассматривается 2 примера, демонстрирующие его применение.

\subsection{Схема алгоритма}
Пусть сохраненные на пользовательской машине данные определены $P = \{P_1,
\dots, P_n\}$, целевой запрос обозначим $P^{\ast}$. Пусть также выполнены условия а) и б) Теоремы \ref{th_mult}.

Шаги алгоритма:
\begin{enumerate}
	\item Проверка условия $M(F^{\ast}) \cap (M(F_1) \cup M(F_2) \cup \dots \cup M(F_n)) = \emptyset$.
	Если выполнено, делаем запрос к БД, кэш в данном случае бесполезен. Иначе переходим на
	следующий шаг.
	\item Проверка условия $M(F^{\ast}) \subseteq (M(F_1) \cap M(F_2) \cap \dots \cap M(F_n))$. Если
	выполнено, можно применять результаты, полученные в теоремах \ref{th_mult}, \ref{th_mult_eq}. Иначе переходим на следующий шаг.
	\item Вычисляем недостающие данные: $P_{n + 1} = \pi_{X^{\ast}} (\sigma_{F_{n + 1}} (R_1 \Join
	\dots \Join R_l))$, $M(F_{n + 1}) = M(F^{\ast}) \setminus M(F_1\ \&\ F_2\ \&\ \dots\ \&\ F_n)$. По построению условие $M(F^{\ast})
	\subseteq (M(F_1) \cap M(F_2) \cap \dots \cap M(F_n) \cap M(F_{n + 1}))$ теперь выполнено.
	$P^{\ast} = \subseteq \pi_{X^{\ast}} ( \sigma_{F^{\ast}[X]} (P_1 \Join \dots \Join
	P_n))$., и мы можем применять результаты теорем \ref{th_mult}, \ref{th_mult_eq} для $P = \{P_1,
	\dots, P_n, P_{n + 1}\}$, $P^{\ast}$.
\end{enumerate}

\subsection{Примеры}
Рассмотрим фрагмент схемы БД, представляющий учебный план в университете:

$$R_1 =\mbox{\it Студенты}\ (\mbox{\bf № студента}, \mbox{ФИО студента},
\mbox{Группа})$$
$$R_2 =\mbox{\it Группы}\ (\mbox{\bf Группа}, \mbox{Факультет})$$
$$R_3 =\mbox{\it Успеваемость}\ (\mbox{\bf № студента}, \mbox{\bf Дисциплина},
\mbox{Оценка})$$

Имена отношений выделены курсивом, их первичные ключи - жирным шрифтом.

\textbf{Пример 1.}

Предположим, что на компьютере пользователя сохранены результаты выполнения следующих запросов:

\begin{enumerate}
	\item Список студентов математического факультета:
	$$P_1 = \pi_{X_1}(\sigma_{F_1} (R_1 \Join R_2)),$$
	где $\pi_{X_1}$ -- проекция по множеству атрибутов $X_1$. $X_1 = \{\text{ФИО студента, Группа}\}$, $\sigma$ -- операция селекции, $F_1$ -- логическая формула:
	$F_1 = (\text{Факультет} = "\text{Математический}")$.

	В результате данного запроса будут получены те кортежи БД, которые удовлетворяют формуле $F_1$,
	причем с сервера будут запрошены только атрибуты $\text{ФИО студента}, \text{Группа}$.

	\item Ведомости по физике:
	$$P_2 = \pi_{X_2}(\sigma_{F_2} (R_1 \Join R_3)),$$
	где $X_2 = \{\text{ФИО студента}, \text{Группа}, \text{Оценка}\}$, $F_2$ --
	логическая формула:	$F_2 = (\text{Дисциплина} = "\text{Физика}")$.

	\item Отчет успеваемости по физике математического факультета:
	$$P^{\ast} = \pi_{X^{\ast}}(\sigma_{F^{\ast}} (R_1 \Join R_2 \Join R_3 )),$$
	где $X^{\ast} = \{\text{ФИО студента}, \text{Группа}, \text{Оценка}\}$, $F^{\ast}$	-- логическая
	формула: $F^{\ast} = (\text{Факультет} = "\text{Математический}"\ \&\
	\text{Дисциплина} = "\text{Физика}")$.
\end{enumerate}

\begin{figure}
	\caption{Области истинности логических формул}
	\begin{tikzpicture}
	\begin{axis}[
	height=6cm,
	width=12cm,
	xlabel={\textit{Факультет}},
	ylabel={\textit{Дисциплина}},
	xticklabels={Физический,Математический,Химический,Экономический},
	xtick={0,1,2,3},
	yticklabels={Физика,Математика,Химия,История},
	ytick={0,1,2,3}
	]
	
	\addplot[
	color = blue,
	mark = *, % A filled circle
	dashed
	] coordinates {(1,0) (1,1) (1,2) (1,3)};
	\addlegendentry{$M(F_1)$};
	
	\addplot[
	color = black,
	mark = *, % A filled circle
	dashed
	] coordinates {(0,0) (1,0) (2,0) (3,0)};
	\addlegendentry{$M(F_2)$};
	
	\addplot[brown, mark = *, only marks] coordinates {(1,0)};
	\addlegendentry{$M(F^{\ast})$};
	
	\end{axis}
	\end{tikzpicture}
	\label{pic-example-1}
\end{figure}

Проверим возможность применения алгоритма. В нашем случае закэшированные данные - это два первых
запроса: $P = \{P_1, P_2\}$. Целевой запрос - $P^{\ast}$. $X^{\ast} = \{\text{ФИО студента, Группа, Оценка}\}, X = X_1 \cup X_2 = \{\text{ФИО студента, Группа, Оценка}\} \Rightarrow X^{\ast} = X$. Таким образом, условие а) выполнено. $\{R_1, R_2\} \cup \{R_1, R_3\} = \{R_1, R_2, R_3\} \subseteq \{R_1, R_2, R_3\}$. Следовательно, условие б) также выполняется.

Выполняем пункт первый алгоритма. Необходимо понять, есть ли вообще что-то общее у закэшированных
запросов и целевого запроса, т.е. проверить условие: $M(F^{\ast}) \cap (M(F_1) \cup M(F_2)) =
\emptyset$. Как показано в пункте \ref{sec-comparison}, данное условие эквивалентно $F^{\ast}\ \&\
(F_1 \vee F_2) \equiv \n{FALSE}$. Подставляя формулы запросов, получаем: $\text{Факультет} =
"\text{Математический}"\ \&\ \text{Дисциплина} = "\text{Физика}"\ \&\ (\text{Факультет} =
"\text{Математический}" \vee \text{Дисциплина} = "\text{Физика}") \equiv \n{FALSE}$. Применим
свойство дистрибутивности: $\text{Факультет} = "\text{Математический}"\ \&\ \text{Дисциплина} =
"\text{Физика}" \equiv \n{FALSE}$. Это, очевидно, неверно.

Выполняем второй шаг алгоритма. Необходимо проверить условие $M(F^{\ast}) \subseteq (M(F_1) \cap M(F_2))$, что, как опять же показано в \ref{sec-comparison}, равносильно $F_1\ \&\ F_2 \vee \neg F^{\ast} \equiv \n{TRUE}$. Подставляя данные, получаем: $\text{Факультет} = "\text{Математический}"\ \&\ \text{Дисциплина} = "\text{Физика}" \vee \neg(\text{Факультет} = "\text{Математический}"\ \&\ \text{Дисциплина} = "\text{Физика}") \equiv \n{TRUE}$. Данное выражение эквивалентно формуле $A \vee \neg A$ и является тождественно истинным при любом значении $A$. Условие выполнено, алгоритм завершен.

На рисунке \ref{pic-example-1} изображены области истинности формул $F_1$, $F_2$, $F^{\ast}$
спроецированные на плоскость $(\text{Факультет}, \text{Дисциплина})$. Из рисунка видно, что область
истинности $M(F^{\ast})$, представляющая из себя точку в данном пространстве, включается в
пересечение областей истинности $M(F_1)$, $M(F_2)$.

\textbf{Пример 2.}

\begin{figure}
	\caption{Области истинности логических формул}
	\begin{tikzpicture}
	\begin{axis}[
	height=6cm,
	width=12cm,
	xlabel={\textit{Факультет}},
	ylabel={\textit{Дисциплина}},
	zlabel={\textit{Оценка}},
	xticklabels={Физ.,Мат.,Хим.,Эконом.},
	xtick={0,1,2,3},
	yticklabels={Физика,Математика,Химия,История},
	yticklabel shift={.3cm},
	ytick={0,1,2,3},
	ztick={2,3,4,5},
	extra x ticks={1},
	extra x tick style={xticklabel=\empty,grid=major}
	]
	
	% M(F_1) section
	\addplot3[
	color = blue,
	mark = *, % A filled circle
	only marks
	] coordinates {
		(1,0,2)
		(1,0,3)
		(1,0,4)
		(1,0,5)
		
		(1,1,2)
		(1,1,3)
		(1,1,4)
		(1,1,5)
		
		(1,2,2)
		(1,2,3)
		(1,2,4)
		(1,2,5)
		
		(1,3,2)
		(1,3,3)
		(1,3,4)
		(1,3,5)
	};
	\addlegendentry{$M(F_1)$};
	
	\addplot3[
	surf,
	fill=blue,
	opacity=0.1,
	fill opacity=0.4,
	restrict y to domain*=0:3,
	restrict z to domain*=2:5,
	forget plot] (1,x,y);
	
	% M(F_2) section
	\addplot3[
	color = black,
	mark = *, % A filled circle
	only marks
	] coordinates {
		(0,0,3)
		(0,0,4)
		(0,0,5)
		
		(1,0,3)
		(1,0,4)
		(1,0,5)
		
		(2,0,3)
		(2,0,4)
		(2,0,5)
		
		(3,0,3)
		(3,0,4)
		(3,0,5)
	};
	\addlegendentry{$M(F_2)$};
	
	\addplot3[
	surf,
	fill=black,
	opacity=0.1,
	fill opacity=0.4,
	restrict x to domain*=0:3,
	restrict z to domain*=3:5,
	forget plot] (x,0,y);
	
	% M(F*) section
	\addplot3[
	brown,
	mark = *, % A filled circle
	only marks
	] coordinates {
		(1,0,2)
		(1,0,3)
		(1,0,4)
		(1,0,5)
	};
	\addlegendentry{$M(F^{\ast})$};
	\end{axis}
	\end{tikzpicture}
	\label{pic-example-2}
\end{figure}

Попробуем немного усложнить задачу. Изменим логическую формулу запроса 2: $F_2 = (\text{Дисциплина}
= "\text{Физика}"\ \&\ \text{Оценка} \geq 3)$. Теперь запрос имеет смысл <<список студентов, сдавших
физику>>.

Условие первого пункта слегка меняется, но результат, очевидно, остается прежним - области
истинности по-прежнему пересекаются.
$\text{Факультет} = "\text{Математический}"\ \&\ \text{Дисциплина} = "\text{Физика}"\ \&\
(\text{Факультет} = "\text{Математический}" \vee \text{Дисциплина} = "\text{Физика}"\ \&\
\text{Оценка} \geq 3) \equiv \n{FALSE}$. Применим свойство дистрибутивности: $\text{Факультет} =
"\text{Математический}"\ \&\ \text{Дисциплина} = "\text{Физика}" \vee \text{Факультет} =
"\text{Математический}"\ \&\ \text{Дисциплина} = "\text{Физика}"\ \&\ \text{Оценка} \geq 3 \equiv
\n{FALSE}$. Это неверно, так как дизъюнкция 2 выражений может быть тождественно ложной лишь в
случае, если оба выражения тождественно ложны.

На втором шаге встречаем различия с прошлым примером. Новые условия формулы $F_2$ сужают область
истинности, и включения не наблюдается. $\text{Факультет} = "\text{Математический}"\ \&\
\text{Дисциплина} = "\text{Физика}"\ \&\ \text{Оценка} \geq 3 \vee (\text{Факультет} \neq
"\text{Математический}" \vee \text{Дисциплина} \neq "\text{Физика}") \equiv \n{TRUE}$. Как уже было
сказано в прошлом примере, такое выражение может быть тождественно истинным лишь в случае
противоположных выражений. Теперь это условие нарушено. Условие не выполнено, переходим на шаг 3
алгоритма.

Третий шаг. Для того, чтобы было возможно воспользоваться кэшем, необходимо сделать запрос на
недостающие данные. По сути эти данные удовлетворяют требованию <<кортежи, которые есть в целевом
запросе, но отсутствующие в кэше>>. Формализация этого требования выглядит, как это было описано в
схеме алгоритма, следующим образом:
$P_3 = \pi_{X^{\ast}} (\sigma_{F_3} (R_1 \Join R_2 \Join R_3))$,  $F_{3} = F^{\ast}\ \&\ \neg(F_1\
\&\ F_2)$. Подставляя данные, получаем: $F_3 = \text{Факультет} = "\text{Математический}"\
\&\ \text{Дисциплина} = "\text{Физика}"\ \&\ \neg (\text{Факультет} = "\text{Математический}"\ \&\
(\text{Дисциплина} = "\text{Физика}"\ \&\ \text{Оценка} \geq 3)) \sim
\text{Факультет} = "\text{Математический}"\ \&\ \text{Дисциплина} = "\text{Физика}"\ \&\ 
(\text{Факультет} \neq "\text{Математический}" \vee \text{Дисциплина} \neq "\text{Физика}"\ \&\
\text{Оценка} = 2) \sim
\text{Факультет} = "\text{Математический}"\ \&\ \text{Дисциплина} = "\text{Физика}"\ \&\
\text{Оценка} = 2$. Таким образом, для того, чтобы воспользоваться кэшем, необходимо получить данные
о студентах математического факультета, не сдавших физику. В других данных необходимости нет, они
уже содержатся в хранилище.

На рисунке \ref{pic-example-2} теперь показана проекция областей истинности на трехмерное
пространство (Факультет, Дисциплина, Оценка). Наглядно видна область пересечения областей истинности
формул $F_1$ и $F_2$. Она не включает точку (Мат., Физика, 2), соответствующую данным, которые мы и
получим, выполнив шаг 3 алгоритма.

\section*{Заключение}
\label{sec-conclusion}
Результаты, полученные в данной работе, решают 2 важных задачи использования технологии, описанной в статье \cite{mosin_zykin}:
\begin{enumerate}
	\item Аналитическая проверка возможности использования кэша    
	\item Аналитическое определение недостающих данных
\end{enumerate}

Оба пункта отражены в схеме алгоритма в шагах 1 и 3 соответственно.

Таким образом, была обоснована возможность использования аналитических проверок для технологии кэширования пользовательских запросов.

Проблема актуализации данных не затрагивается в этой работе. Однако она может быть решена
путем учета запросов на сервере и обновлении данных при помощи триггеров.

В дальнейшем планируется применить методы и алгоритмы, изложенные в данной статье для разработки ПО, являющегося прослойкой над СУБД и управляющего использованием кэша, снижая тем самым количество передаваемых данных и общее время работы системы.

Предложенная технология будет использована при динамическом построении многомерных данных.
Промежуточные представления имеют ту же структуру данных, что и таблицы соединений, используемые для
построения гиперкубов. Сохраненные представления данных могут храниться на компьютере пользователя-аналитика и существенно сократить время на формирование данных, необходимых для принятия решений.


\begin{biblio}
%статья
\bibitem{mosin_zykin}
Мосин,~С.В. Кэширование запросов к реляционной базе данных с
использованием областей истинности / С.В.~Мосин, С.В.~Зыкин //
Моделирование и анализ информационных систем. --- 2015. --- No 2. --- С. 248--258.

%книга
\bibitem{hilbert}
Гильберт,~Д. Основы теоретической логики. /
Д.~Гильберт, В.~Аккерман --- Москва: Изд-во КомКнига, 2010. --- 306~с.

\bibitem{mendelson}
Мендельсон,~Э. Введение в математическую логику. /
Э.~Мендельсон --- Москва: Изд-во Наука, 1971. --- 320~с.


\bibitem{church}
Чёрч,~А. Введение в математическую логику. /
A.~Чёрч --- Москва: Изд-во УРСС, 2009. --- 480~с.

\bibitem{date}
Date,~C.J. SQL and Relational Theory. Second Edition / C.J.~Date --- O'Reilly, 2012. --- 448 p.
\end{biblio}


% Сведения об авторах (Ф.И.О.(полностью), степень, звание, кафедра (отдел), вуз, e-mail)
{Мосин Сергей Владимирович,
аспирант,
инженер-исследователь лаборатории методов преобразования и представления информации Института Математики им. С.Л. Соболева СО РАН (Омск, Российская Федерация),
svmosin@gmail.com}

{\phantom{eee} \hrule \vskip 4 pt}
\classify{} % Код MSC не нужен
%\classify{MSC 00000} % Коды MSC см. http://www.ams.org/msc/
\author{S.V.~Mosin, {\rm  Sobolev's Institute of Mathematics (Omsk, Russia)}}
\title{Truth space comparison of Relational Database queries}
\maketitle{}

\begin{abstract}%
We propose new methods and algorithms of analytical truth space comparison for Relational Database queries.
Such a comparison aims to define the possibility of partial or full cache usage. The cache is stored on
user's computer and Database server is supposed to be remote. In case user query's result is contained in
cache we can simply take the data from there avoiding any server requests. The suggested method may also be
used for defining data missing in cache and performing query to only receive that data. Analytical
computations are also used to achieve this and it differs our approach from existing ones. Query comparison
algorithms are based on the Predicate Logic theory. Formulas are presented by logical constraints in SQL
and predicates correspond to SQL operations.

\keywordsen{Relational Database, Cache, Truth space}
\end{abstract}

\begin{biblio_lat}
%\itemsep -2pt
%статья
\bibitem{mosin_zykin}
Mosin~S.V., Zykin~S.V. Truth space method for caching database queries // Modeling and analysis of information
systems. 2015. Vol.~22, No.~2, P.~248--258

%книга
\bibitem{hilbert}
Hilbert~D., Ackermann~W. Principles of Mathematical Logic. AMS Chelsea Publishing, 1950. 172~p.

\bibitem{mendelson}
Mendelson~E. Introduction to Mathematical Logic, Fifth Edition. CRC Press, 2009. 469~p.

\bibitem{church}
Church~A. Introduction to Mathematical Logic. Princeton University Press, 1996. 378~p.

\bibitem{date}
Date~C.J. SQL and Relational Theory. Second Edition. O'Reilly, 2012. 448~p.
\end{biblio_lat}

%\begin{flushright}
%{ \it Поступила в редакцию 26 июля 2011 г.}
%\end{flushright}

\end{document}
