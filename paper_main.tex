\documentclass[10pt,a4paper]{article}

\usepackage{amssymb,amsmath}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{xcolor}
\usepackage{mdwlist}
\usepackage{enumitem}

\floatname{algorithm}{Алгоритм}

\newtheorem{theorem}{Теорема}
\newtheorem{mydef}{Определение}
\newtheorem{statement}{Утверждение}
\newtheorem*{consequence}{Следствие}

\def \eval #1#2{\left.#1\right\vert_{#2}}
\def \<#1> {\langle #1 \rangle}
\def \n #1{\mathit{#1}}
\def \bigcupn {\bigcup\limits_{v=1}^{n}}

\title{Сравнение областей истинности запросов к реляционной базе данных}

\begin{document}
\maketitle
\section*{Введение}
Данная работа развивает и объясняет идеи, описанные в статье \ref{mosin_zykin}, представляя подходы к аналитическому сравнению логических формул, используемых в универсальных реляционных запросах. Напомним, (опр. унив. р. запроса).

Основным инструментом работы с логическими формулами является аппарат математической логики, конкретно, логики первого порядка, или логики предикатов \ref{uchebnik_1}, \ref{uchebnik_2}, \ref{uchebnik_3}. Данная работа не ставит целью получение новых результатов в области математической логики, а лишь использует имеющуюся теорию в применении к логическим ограничениям языка SQL, расширяя таким образом возможности анализа пользовательских запросов по сравнению с классическими подходами СУБД, где нет возможности частичного или комбинированного использования закэшированных запросов.

В книге \ref{book1} подробно описано то, как логика предикатов используется в языке SQL в виде реляционного исчисления (relational calculus), а также приведены основные эквивалентности логических предикатов, используемые в данной статье.

%Данная проблема связана с проблемой трансляции запросов из естественного языка в SQL, поскольку там тоже приходится рассматривать отображения структур языка SQL на некоторые сторонние объекты.

\section{Постановка задачи}
Будем рассматривать реляционную базу данных со схемой $R = \{R_1, R_2, \dots, R_n\}$.

\begin{mydef}
	Универсальным реляционным запросом называется запрос следующего вида:
	$$P = \pi_X(\sigma_{F} (R_1 \Join \dots \Join R_m )), m \in [1, \dots, n]$$
\end{mydef}

Логические формулы, по которым проводится селекция, будем рассматривать в дизъюнктивной нормальной форме. В общем случае формула $F$ имеет вид

\begin{equation}
F = K_1 \vee K_2 \vee \dots \vee K_m ,
\label{def_F_1}
\end{equation}
\begin{equation}
K_i = T_1\ \&\ T_2 \dots \&\ T_n, i = 1, \dots, m ,
\label{def_F_2}
\end{equation}
где $T_j, j = 1, \dots, n$ - предикаты, в которых явным образом
специфицированы расширенные имена атрибутов $R_i.A_j$ (атрибут $A_j$ в отношении
$R_i$):

Возможные значения  $T_j$:
\begin{itemize}
	\item операция сравнения $ \n{Expr}_1\ \theta\ \n{Expr}_2\ $, $\theta$ – операция
	сравнения $(\theta \in \{=, \neq, >, <, \leq, \geq\})$, $\n{Expr}_i$ –
	согласованные по типам допустимые выражения, определенные на множестве
	расширенных имен атрибутов и констант;
	\item операция $\n{Expr}_1\ \n{[NOT]}\ \n{BETWEEN}\ \n{Expr}_2\ \n{AND}\
	\n{Expr}_3$ (содержимое в прямоугольных скобках $[*]$ для предиката не
	является обязательным при написании);
	\item операция $\n{Expr}\ \n{[NOT]}\ \n{IN}\ S$, где $S$ – список значений либо
	подзапрос, результатом которого является столбец атрибута $A_j$ в отношении
	$R_i$;
	\item операция $\n{Str}_1\ \n{[NOT]}\ \n{LIKE}\ \n{Str}_2$, где $\n{Str}_i$ –
	строки;
	\item операция $\n{Expr}\ \theta\ \n{ALL/ANY}\ S$.
\end{itemize}

\begin{mydef}
	Множество атрибутов, входящих в формулу, выражает размерность формулы и
	обозначается $\<F> $.
	
	\begin{equation}
	\<F> = \{R_1^F.A_1^F, \dots, R_k^F.A_k^F\}
	\label{def_F_3}
	\end{equation}
\end{mydef}

Перечисленные варианты операций используют не все возможности языка SQL.
Например, предикат $\n{EXISTS}$ не используется, поскольку в нем явно не
специфицированы расширенные имена атрибутов, предикат $\n{NULL}$ используется
в данной работе для другой цели.

В статье \ref{mosin_zykin} приведен алгоритм преобразования логических формул, которое позволяет избежать получения значения $\n{UNKNOWN}$ в результате вычисления значений формул. Далее будем предполагать, что все формулы $F$ являются преобразованными.

Введем в рассмотрение множество $\mathcal{A} =$ $\{(a_1, \dots, a_n)
\mid a_i \in Dom(A_i), i=1,\dots,n\}$, где $Dom(A_i)$ - множество всех допустимых значений атрибута $A_i$.
Декартово произведение $Dom(A_1)\times Dom(A_2)\times \dots \times Dom(A_n)$ - $n$-мерное пространство
значений всех атрибутов базы данных.

\begin{mydef}
	Областью истинности логической формулы $F$, заданной (\ref{def_F_1}),
	(\ref{def_F_2}), (\ref{def_F_3}), является множество, определяемое по следующему
	правилу: $M (F) = \{a \in \mathcal{A} \mid F(a) = \n {TRUE}\}$.
\end{mydef}

В соответствии с данными определениями легко понять, как будут устроены операции
над областями истинности, соответствующими формулам. $M (F)$ для некоторой формулы
$F$, заданной своей ДНФ, является объединением областей истинности, представленных
отдельными конъюнктами формулы. Область истинности каждого конъюнкта определяется
определяется как пересечение областей истинности предикатов, входящих в него.

Далее введем определения, касающиеся модификации вхождения атрибутов в
логические формулы.

\begin{mydef}
	Проекцией логической формулы $F$, заданной (\ref{def_F_1}), (\ref{def_F_2}),
	(\ref{def_F_3}), на множество атрибутов $X$ называется логическая
	формула $F[X], \<F[X]> $
	$= X$, в которой все термы, содержащие
	атрибуты $R_i^F.A_i^F \notin X$, заменены на тривиальный терм $\n{TRUE}$.
	\label{projection}
\end{mydef}

Основные теоретические результаты, позволяющие судить о возможности использования кэша при выполнении запросов:
\begin{theorem}
	$P^{\ast} \subseteq \pi_{X^{\ast}} ( \sigma_{F^{\ast}[X]} (P_1 \Join \dots \Join
	P_n))$, где $X = \bigcupn X_{v}$ если:
	\\а) $X^{\ast} \subseteq X$
	\\б)
	$ \bigcupn \{R^{v}_{1}, \ldots, R^{v}_{s(v)}\} = \{R'_{1}, \ldots, R'_{s'}\}
	\subseteq
	\{R^{\ast}_{1}, \ldots, R^{\ast}_{l}\} $
	\\в) $M(F^{\ast}) \subseteq M(F_{v}), v = 1,\dots,n $.
	\label{th_mult}
\end{theorem}

\begin{theorem}
	$P^{\ast} =  \pi_{X^{\ast}} ( \sigma_{F^{\ast}} (P_1 \Join \dots \Join
	P_n))$, где $X = \bigcupn X_{v}$ если:
	\\а) $X^{\ast} \subseteq X$, $X_v \supseteq \<\Join_{i=1}^{s(v)} R^v_i> \cap (\bigcup\limits_{\substack{w=1\\ w \neq v}}^{n} \<\Join_{i=1}^{s(w)} R^w_i> ), v = 1,\dots,n$
	\\б)
	$ \bigcupn \{R^{v}_{1}, \ldots, R^{v}_{s(v)}\} = \{R'_{1}, \ldots, R'_{s'}\}
	= \{R^{\ast}_{1}, \ldots, R^{\ast}_{l}\} $
	\\в) $M(F^{\ast}) \subseteq M(F_{v}), v = 1,\dots,n $
	\\г) $ \<F^{\ast}> \subseteq X $.
	\label{th_mult_eq}
\end{theorem}

\section{Логические операции над предикатами}
Для проверки условий теорем необходимо уметь сравнивать логические формулы, не прибегая к запросам
на сервер. Для этого, в свою очередь, нам понадобится вычислять значение логических операций $\vee,
\&, \neg$ над предикатами $T_j, j=1, \dots, n$, из которых состоят логические формулы. Определение значения логической формулы аналитически возможно в случае, если формула не зависит от значений атрибутов БД. Приведение к такому виду возможно в ряде изложенных далее случаев.

\subsection{Упрощение конъюнкции и дизъюнкции простых предикатов}
\begin{enumerate}
\item $ \n{Expr}_1\ \theta\ \n{Expr}_2\ $, $(\theta \in \{=, \neq, >, <, \leq, \geq\})$\\
Данный тип операций определяет простейшие арифметические операции равенства и неравенства. Сравнение
таких предикатов сводится к применению элементарных правил решения неравенств.

Пусть даны следующие предикаты:
\begin{itemize}
    \item $T_1 = (R_i.A_j\ \theta_1\ a),\ a \in Dom(R_i.A_j)$
    \item $T_2 = (R_i.A_j\ \theta_2\ b),\ b \in Dom(R_i.A_j)$
\end{itemize}

Рассмотрим всевозможные комбинации конъюнкции и дизъюнкции данных типов предикатов, при которых в
результате получается тривиальное значение $\n{TRUE}$ либо $\n{FALSE}$.

Заметим, что операции $\leq,
\geq$ сводятся к операциям $<, >, =, \neq$: $x_1 \leq x_2 \sim x_1 < x_2 \vee x_1 = x_2$, поэтому мы исключаем их из дальнейшего рассмотрения.

Также обратим внимание, что если $\theta_1 = \theta_2$, то $T_1\ \&\ T_2 \equiv \n{TRUE} \iff a = b$.
Далее рассматриваем только различные операции $\theta_1$ и $\theta_2$.

\begin{enumerate}[label=\Roman*]
  \item $\theta_1 = $ ``$=$''
  \begin{enumerate}
  	\item $\theta_2 = $ ``$\neq$''  	
  	$$T_1\ \&\ T_2 \equiv \n{TRUE} \iff a = b$$
  	$$T_1\ \&\ T_2 \equiv \n{FALSE} \iff a \neq b$$

  	\item $\theta_2 = $ ``$<$''
  	$$T_1\ \&\ T_2 \equiv \n{FALSE} \iff a > b$$

  	\item $\theta_2 = $ ``$>$''
  	$$T_1\ \&\ T_2 \equiv \n{FALSE} \iff a < b$$
  \end{enumerate}

  \item $\theta_1 = $ ``$\neq$''

  Никакие прочие операции не дают в результате тождественной истины или лжи при проведении конъюнкции или дизъюнкции с $T_1$ в данном случае.

  \item $\theta_1 = $ ``$<$''
  \begin{enumerate}
  	\item $\theta_2 = $ ``$>$''
  	
  	$$T_1\ \&\ T_2 \equiv \n{FALSE} \iff a < b$$
  	$$T_1 \vee T_2 \equiv \n{TRUE} \iff a \geq b$$
  \end{enumerate}
\end{enumerate}


\item $\n{Expr}_1\ \n{[NOT]}\ \n{BETWEEN}\ \n{Expr}_2\ \n{AND}\ \n{Expr}_3$\\
Эта и дальнейшие операции (кроме $\n{LIKE}$) сводятся к операциям первого типа:
\begin{enumerate}[label=\Roman*]
  \item $\n{Expr}_1\ \n{BETWEEN}\ \n{Expr}_2\ \n{AND}\ \n{Expr}_3$\\
  $T = (\n{R_i.A_j}\ \n{BETWEEN}\ a\ \n{AND}\ b),\ a, b \in Dom(R_i.A_j)$
  Эквивалентное представление данной операции: $T = (a \leq \n{R_i.A_j} \leq b)$
  \item $\n{Expr}_1\ \n{NOT}\ \n{BETWEEN}\ \n{Expr}_2\ \n{AND}\ \n{Expr}_3$\\
  $T = (\n{R_i.A_j}\ \n{NOT}\ \n{BETWEEN}\ a\ \n{AND}\ b),\ a, b \in Dom(R_i.A_j)$
  Эквивалентное представление данной операции: $T = (\n{R_i.A_j} \leq a \vee \n{R_i.A_j} \geq b)$
\end{enumerate}


\item $\n{Expr}\ \n{[NOT]}\ \n{LIKE}\ \n{Str}$,\\ $\n{Expr}$ -- атрибут строкового типа данных,
$\n{Str}$ -- строка особого типа, содержащая управляющие символы языка SQL. К ним относятся:
\begin{itemize}
  \item '\%' Данный символ совпадает при сравнении с любым количеством любых символов строки
  \item '\_' Данный символ совпадает при сравнении с одним любым символом строки
\end{itemize}

Различные диалекты языка SQL от разных производителей СУБД дополняют этот список другими
управляющими конструкциями, так что он может отличаться в зависимости от реализации. Но так или
иначе сравнение предикатов такого вида имеет схожую схему. По сути данная операция представляет из
себя упрощенное регулярное выражение. Проведение таких операций, как дизъюнкция, конъюнкция и
отрицание, осуществляется точно также как для регулярных выражений.


\item \label{itm:IN_S} $\n{Expr}\ \n{[NOT]}\ \n{IN}\ S$, где $S$ - список значений или подзапрос,
результат которого - это множество значений атрибута $R_i.A_j$.
\begin{enumerate}[label=\Roman*]
  \item $\n{Expr}\ \n{IN}\ S$\\
  Если $S$ - это список заранее заданных значений:\\
  $T = (\n{R_i.A_j}\ \n{IN}\ \{s_1, s_2, \dots, s_l \}),\ s_k \in Dom(R_i.A_j), k = 1, \dots, l$\\
  Эквивалентное представление: $T = (\bigvee\limits_{k=1}^{l} \n{R_i.A_j} = s_k)$\\
  Если $S$ - это подзапрос:\\
  $T = (\n{R_i.A_j}\ \n{IN}\ \pi_{R_i.A_j} (\sigma_F (R_1 \Join \dots \Join R_n)))$\\
  \item $\n{Expr}\ \n{NOT}\ \n{IN}\ S$\\
  Если $S$ - это список заранее заданных значений:\\
  $T = (\n{R_i.A_j}\ \n{NOT}\ \n{IN}\ \{s_1, s_2, \dots, s_l \}),\ s_k \in Dom(R_i.A_j), k = 1,
  \dots, l$\\
  Эквивалентное представление: $T = (\bigwedge\limits_{k=1}^{l} \n{R_i.A_j} \ne s_k)$\\
  Если $S$ - это подзапрос:\\
  $T = (\n{R_i.A_j}\ \n{IN}\ \pi_{R_i.A_j} (\sigma_F (R_1 \Join \dots \Join R_n)))$\\
\end{enumerate}


\item \label{itm:ALL/ANY_S} $\n{Expr}\ \theta\ \n{ALL/ANY}\ S$.\\
Данная операция является обобщением операций первого типа и сводится к нему в случае простого списка
значений.
\begin{enumerate}[label=\Roman*]
  \item $\n{Expr}\ \theta\ \n{ALL}\ S$\\ Если $S$ - это список заранее заданных значений:\\
  $T = (\n{R_i.A_j}\ \theta\ \n{ALL}\ \{s_1, s_2, \dots, s_l \}),\ s_k \in Dom(R_i.A_j), k = 1,
  \dots, l$\\  
  Эквивалентное представление:\\
  $T = (\n{R_i.A_j}\ \theta\ s_1\ \&\ \n{R_i.A_j}\ \theta\ s_2\ \&\ \dots \&\ \n{R_i.A_j}\ \theta\
  s_k)$\\
  Если $S$ - это подзапрос:\\
  $T = (\n{R_i.A_j}\ \theta\ \n{ALL}\ \pi_{R_i.A_j} (\sigma_F (R_1 \Join \dots \Join R_n)))$\\
  \item $\n{Expr}\ \theta\ \n{ANY}\ S$\\
  $T = (\n{R_i.A_j}\ \theta\ \n{ANY}\ \{s_1, s_2, \dots, s_l \}),\ s_k \in Dom(R_i.A_j), k = 1,
  \dots, l$\\  
  Эквивалентное представление:\\
  $T = (\n{R_i.A_j}\ \theta\ s_1\ \vee\ \n{R_i.A_j}\ \theta\ s_2\ \vee\ \dots \vee\ \n{R_i.A_j}\
  \theta\ s_k)$\\
  Если $S$ - это подзапрос:\\
  $T = (\n{R_i.A_j}\ \theta\ \n{ANY}\ \pi_{R_i.A_j} (\sigma_F (R_1 \Join \dots \Join R_n)))$\\
\end{enumerate}
\end{enumerate}

\subsection{Упрощение конъюнкции и дизъюнкции предикатов, содержащих подзапросы}
Если в операциях \ref{itm:IN_S} и \ref{itm:ALL/ANY_S} типа встречается подзапрос,
аналитическое сравнение таких предикатов возможно только в некоторых частных случаях. Дело в том,
что нельзя заранее определить область истинности таких предикатов, так как она зависит от реализации
базы данных. Использование же информации о БД противоречит аналитическому подходу. Рассмотрим
условия, при которых все-таки возможно их сравнивать аналитически.

Пусть подзапросы имеют следующий вид:
$$S_1 = \pi_{R_i.A_j} (\sigma_{F_1} (R_1^1 \Join \dots \Join R_l^1))$$
$$S_2 = \pi_{R_i.A_j} (\sigma_{F_2} (R_1^2 \Join \dots \Join R_k^2))$$

$S_1$ и $S_2$ являются множествами и, следовательно, могут быть следующие ситуации:
\begin{enumerate}
  \item $S_1 \cap S_2 = \emptyset $\\
  Определить, что подзапросы точно не пересекаются, аналитически можно, если $M(F_1) \cap M(F_2) =
  \emptyset$. В данном случае наблюдаются следующие эквивалентности:
  \begin{enumerate}
    \item $(\n{R_i.A_j}\ \n{IN}\ S_1)\ \&\ (\n{R_i.A_j}\ \n{IN}\ S_2) \equiv \n{FALSE}$
    \item $(\n{R_i.A_j}\ = \n{ALL}\ S_1)\ \&\ (\n{R_i.A_j}\ = \n{ALL}\ S_2) \equiv \n{FALSE}$
  \end{enumerate}
  \item $S_1 \cap S_2 \neq \emptyset $\\
  В общем случае нет возможности установить упрощения к виду тождественной истины/лжи.
\end{enumerate}

\subsection{Операция отрицания для всех типов предикатов}
Логическое отрицание ставит в соответствие противоположный предикат в каждом из случаев.
\begin{enumerate}
  \item $ \n{Expr}_1\ \theta\ \n{Expr}_2\ $, $(\theta \in \{=, \neq, >, <, \leq, \geq\})$\\
  $T = (\n{R_i.A_j}\ \theta\ a)\ \rightarrow \neg T = (\n{R_i.A_j}\ \neg \theta\ a),
  a \in Dom(R_i.A_j)$
    \begin{itemize}
      \item $T = (\n{R_i.A_j} = a) \rightarrow \neg T =  (\n{R_i.A_j}\ \neq a)$
      \item $T = (\n{R_i.A_j} > a) \rightarrow \neg T =  (\n{R_i.A_j}\ < a)$
      \item $T = (\n{R_i.A_j} \geq a) \rightarrow \neg T = (\n{R_i.A_j}\ \leq
      a)$
    \end{itemize}
  \item $\n{Expr}_1\ \n{[NOT]}\ \n{BETWEEN}\ \n{Expr}_2\ \n{AND}\ \n{Expr}_3$\\
  $T = (\n{R_i.A_j}\ \n{BETWEEN}\ a\ \n{AND}\ b),\ a, b \in Dom(R_i.A_j) \rightarrow$\\
  $\rightarrow \neg T = (\n{R_i.A_j}\ \n{NOT}\ \n{BETWEEN}\ a\ \n{AND}\ b)$
  \item $\n{Expr}\ \n{[NOT]}\ \n{LIKE}\ \n{Str}$\\
  $T = (\n{R_i.A_j}\ \n{LIKE}\ \n{Str}) \rightarrow \neg T = (\n{R_i.A_j}\ \n{NOT}\ \n{LIKE}\
  \n{Str})$
  \item $\n{Expr}\ \n{[NOT]}\ \n{IN}\ S$\\
  $T = (\n{R_i.A_j}\ \n{IN}\ S)\ \rightarrow \neg T = (\n{R_i.A_j}\ \n{NOT}\ \n{IN}\ S)$
  \item $\n{Expr}\ \theta\ \n{ALL/ANY}\ S$\\
  $T = (\n{R_i.A_j}\ \theta\ \n{ALL}\ S)\ \rightarrow \neg T = (\n{R_i.A_j}\ \neg \theta\ \n{ANY}\ S
  )$
\end{enumerate}


\section{Операции над областями истинности логических формул}
\label{comparison}
Здесь и далее будем рассматривать только случай нескольких промежуточных
представлений как более общий.

Для выполнения условий теорем \ref{th_mult}, \ref{th_mult_eq} требуется установить включение области
истинности формулы пользовательского запроса $M(F^{\ast})$ в область истинности формул промежуточных представлений $M(F_1), M(F_2), \dots$\\
$\dots, M(F_n)$, или $M(F^{\ast}) \subseteq M(F_{v}),
v = 1,\dots, n$, то есть должно быть выполнено $M(F^{\ast}) \subseteq M(F_1)\ \&\ M(F^{\ast}) \subseteq M(F_2)\ \&\ \dots\ \&\ M(F^{\ast}) \subseteq M(F_n) \equiv \n{TRUE} \iff M(F^{\ast}) \subseteq M(F_1\ \&\ F_2\ \&\ \dots\ \&\ F_n) \equiv \n{TRUE} \iff F^{\ast} \rightarrow F_1\ \&\ F_2\ \&\ \dots\ \&\ F_n \equiv \n{TRUE} \iff F_1\ \&\ F_2\ \&\ \dots \&\ F_n \vee \neg F^{\ast} \equiv
\n{TRUE} $.

Проверка на пустоту пересечения областей истинности логических формул осуществляется следующим образом: $M(F^{\ast}) \cap (M(F_1) \cup M(F_2) \cup \dots \cup M(F_n)) = \emptyset \iff M(F^{\ast}\ \&\ (F_1 \vee F_1 \vee \dots \vee F_n)) = \emptyset \iff
F^{\ast}\ \&\ (F_1 \vee F_1 \vee \dots \vee F_n) \equiv \n{FALSE}$.

Практическая проверка данных условий аналитическим способом возможна путем упрощения формул при
помощи правил, изложенных в предыдущем пункте.

Для получения недостающих в кэше данных необходимо уметь строить формулу, область истинности которой
равна разности областей истинности исходных формул:
$M(F^{\ast}) \setminus M(F_1 \vee F_1 \vee \dots \vee F_n) = M(F_{n + 1})$.
Такая формула $F_{n + 1}$, очевидно, выражается следующим образом: $F_{n + 1} = F^{\ast}\ \&\ \neg(F_1 \vee F_1 \vee \dots \vee F_n)$.


\section{Алгоритм использования кэшированных данных}
Далее приводится схема алгоритма аналитической проверки логических ограничений и определения
недостающих в кэше данных.

Пусть сохраненные на пользовательской машине данные определены $P = \{P_1,
\dots, P_n\}$, целевой запрос обозначим $P^{\ast}$. Пусть также выполнены условия а) и б) Теоремы \ref{th_mult}.

\begin{enumerate}[label=\bfseries Шаг \arabic*:]
  \item Проверка условия $M(F^{\ast}) \cap (M(F_1) \cup M(F_2) \cup \dots \cup M(F_n)) = \emptyset$.
  Если выполнено, делаем запрос к БД, кэш в данном случае бесполезен. Иначе переходим на
  следующий шаг.
  \item Проверка условия $M(F^{\ast}) \subseteq (M(F_1) \cup M(F_2) \cup \dots \cup M(F_n))$. Если
  выполнено, можно применять результаты, полученные в теоремах \ref{th_mult}, \ref{th_mult_eq}. Иначе переходим на следующий шаг.
  \item Вычисляем недостающие данные: $P_{n + 1} = \pi_{X^{\ast}} (\sigma_{F_{n + 1}} (R_1 \Join
  \dots \Join R_l))$, $M(F_{n + 1}) = M(F^{\ast}) \setminus M(F_1 \vee F_2 \vee \dots \vee F_n)$. По построению условие $M(F^{\ast})
  \subseteq (M(F_1) \cup M(F_2) \cup \dots \cup M(F_n) \cup M(F_{n + 1}))$ теперь выполнено, и мы
  можем применять результаты теорем \ref{th_mult}, \ref{th_mult_eq} для $P = \{P_1, \dots, P_n,\\ P_{n + 1}\}$, $P^{\ast}$.
\end{enumerate}

\section*{Заключение}
Результаты, полученные в данной работе, решают 2 важных задачи использования технологии, описанной в статье \ref{mosin_zykin}:
\begin{enumerate}
  \item Аналитическая проверка возможности использования кэша    
  \item Аналитическое определение недостающих данных
\end{enumerate}

Оба пункта отражены в схеме алгоритма в шагах 1 и 3 соответственно.

Таким образом, была обоснована возможность использования аналитических проверок для технологии кэширования пользовательских запросов.

Проблема актуализации данных не затрагивается в этой работе. Однако она может быть решена
путем учета запросов на сервере и обновлении данных при помощи триггеров.

В дальнейшем планируется применить методы и алгоритмы, изложенные в данной статье для разработки ПО, являющегося прослойкой над СУБД и управляющего использованием кэша, снижая тем самым количество передаваемых данных и общее время работы системы.

Предложенная технология будет использована при динамическом построении многомерных данных.
Промежуточные представления имеют ту же структуру данных, что и таблицы соединений, используемые для
построения гиперкубов. Сохраненные представления данных могут храниться на компьютере пользователя-аналитика и существенно сократить время на формирование данных, необходимых для принятия решений.
\end{document}